{
  "name": "jasmine-react-helpers",
  "version": "0.2.0",
  "description": "a small suite of helper functions to make unit testing React.js components painless.",
  "main": "src/jasmine-react.js",
  "author": {
    "name": "Tom Hallett"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tommyh/jasmine-react.git"
  },
  "devDependencies": {
    "browserify": "^4.2.3",
    "grunt": "^0.4.5",
    "grunt-karma": "^0.8.3",
    "karma": "^0.12.19",
    "karma-browserify": "^0.2.1",
    "karma-chrome-launcher": "^0.1.4",
    "karma-firefox-launcher": "^0.1.3",
    "karma-jasmine": "^0.1.5",
    "karma-phantomjs-launcher": "^0.1.4",
    "karma-react-jsx-preprocessor": "^0.1.1",
    "react": "^0.8.0",
    "react-tools": "^0.11.1"
  },
  "readme": "*jasmine-react* is a small suite of helper functions to make unit testing React.js components painless.\n\n# Why do I need jasmine-react.js?\n\nReact.js' architecture is based on the idea that mutation is hard, so your React.js components should represent a state machine which can represent your UI under any state.  This is an extremely powerful idea and means that you will often compose components inside of other components.  While this is great for code reuse, it makes isolating one component for a unit test slightly more difficult.  React.js will also provide some very helpful features (like auto binding), which make it more difficult to get under the covers and stub things out.  jasmine-react aims to solve these testing issues.\n\n# Synopsis\n\nHere's an overview of how jasmineReact can be used:\n\n### Spying on a method in a React Class\n\n```javascript\n/** @jsx React.DOM */\nwindow.HelloWorld = React.createClass({\n  getInitialState: function(){\n    return { number: this.randomNumber() };\n  },\n  randomNumber: function(){\n    return Math.random();\n  },\n  render: function() {\n    return (<div>Hello {this.state.number}</div>);\n  }\n});\n\ndescribe(\"HelloWorld\", function(){\n  it(\"can spy on a function for a React class\", function(){\n    jasmineReact.spyOnClass(HelloWorld, \"randomNumber\").andReturn(42);\n\n    // jasmineReact wraps React.renderComponent, so you don't have to worry\n    //  about the async nature of when the actual DOM get's rendered, or selecting\n    //  where your component needs to get rendered (default is #jasmine_content)\n    var myWorld = jasmineReact.renderComponent(<HelloWorld />);\n\n    expect(myWorld.state.number).toBe(42);\n  });\n\n  it(\"can assert that a spy has been called\", function(){\n    jasmineReact.spyOnClass(HelloWorld, \"randomNumber\");\n\n    jasmineReact.renderComponent(HelloWorld());\n\n    // because we spy on the class and not the instance, we have to assert that the\n    //   function on the class' prototype was called.\n    expect(jasmineReact.classPrototype(HelloWorld).randomNumber).toHaveBeenCalled();\n  });\n});\n```\n\n### Replacing a component's subcomponent with a test double\n\nThis is very helpful for isolating your component tests to just that component, and avoiding\ntesting its subcomponents.\n\n```javascript\n/** @jsx React.DOM */\nwindow.Avatar = React.createClass({\n  render: function() {\n    return (\n      <div>\n        <Profile username=\"Zuck\" ref=\"pic\" />\n      </div>\n    );\n  }\n});\n\nwindow.Profile = React.createClass({\n  render: function(){\n    throw(\"I like to blow up\");\n  }\n});\n\ndescribe(\"Avatar\", function(){\n\n  it(\"should spy on a subcomponent and use a test double component\", function(){\n   jasmineReact.createStubComponent(window, \"Profile\");\n\n   // This line won't throw the \"I like to blow up\" error because we've replaced the class with a test double!\n   var avatar = jasmineReact.renderComponent(<Avatar />);\n\n   expect(avatar.refs.pic.props.username).toBe(\"Zuck\")\n  });\n\n});\n```\n\n### Adding a method to a component class\n\nThis is needed to make a test double implement an interface which the component under test requires.\n\n```javascript\n/** @jsx React.DOM */\nwindow.Avatar = React.createClass({\n  render: function() {\n    return (\n      <div>\n        <Profile username=\"Zuck\" ref=\"pic\" />\n      </div>\n    );\n  },\n\n  rotateProfile: function(){\n    this.refs.pic.rotate();\n  }\n});\n\ndescribe(\"Avatar\", function(){\n  describe(\"rotateProfile\", function(){\n    it(\"should call 'rotate' on the Profile subcomponent\", function(){\n      var profileClassStub = jasmineReact.createStubComponent(window, \"Profile\");\n\n      // We could also do: jasmineReact.addMethodToClass(window.Profile, \"rotate\", function(){});\n      jasmineReact.addMethodToClass(profileClassStub, \"rotate\", function(){});\n      jasmineReact.spyOnClass(profileClassStub, \"rotate\");\n\n      var avatar = jasmineReact.renderComponent(<Avatar />);\n\n      expect(jasmineReact.classPrototype(profileClassStub).rotate).not.toHaveBeenCalled();\n      avatar.rotateProfile();\n      expect(jasmineReact.classPrototype(profileClassStub).rotate).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n# API\n\n## jasmineReact.renderComponent\n\n`jasmineReact.renderComponent(component, [container], [callback]);`\n\nWhen rendering a React component, this is a convenience function for `React.renderComponent`.\n\nIt has a few helpful features:\n\n* the component is actually rendered to an attached DOM node (unlike `React.addons.TestUtils.renderIntoDocument which\n  renders into a detached DOM node).\n* the component will be automatically unmounted after the test is complete.\n  NOTE: If you call React.renderComponent in a jasmine test and the component is not unmounted, that component\n  will pollute any subsequent tests which try to render into that container.\n* the container argument is optional.  By default it will be: `document.getElementById(\"jasmine_content\").  If you\n  want to override this behavior, look at the documentation for `jasmineReact.getDefaultContainer`\n* `React.renderComponent` will return before the rendering has occurred.  `jasmineReact.renderComponent` will wait\n  until the async render has been performed.\n\nJust like `React.renderComponent`, this method will return the component instance.\n\n\n## jasmineReact.spyOnClass\n\n`jasmineReact.spyOnClass(componentClass, functionName);`\n\nWhen you want to render a component and stub on a function for that component, you need to spyOn the function\nbefore the instance has been created because important functions (default props/state, render) happen during initialization.\nThis means you need to spyOn the component class, not the component instance.\n\nThis function performs the following:\n\n* uses the vanilla `jasmine.spyOn` to spy on the component class prototype\n* React does some performance tricks for [autobinding functions](http://facebook.github.io/react/blog/2013/07/02/react-v0-4-autobind-by-default.html),\n  so this function will abstract those away from you\n* returns a regular jasmine spy object, so you can chain additional spy functions onto it.\n  For example: `jasmineReact.spyOnClass(Avatar, \"getWidth\").andCallFake(function(){ return 120; });`\n\n## jasmineReact.classPrototype\n\n`jasmineReact.classPrototype(componentClass)`\n\nAfter you've spied on a component class using `jasmineReact.spyOnClass`, you will need to assert things\non that component class.  This function returns you the object you want to make your assertions against.\n\n```js\njasmineReact.spyOnClass(Avatar, \"getWidth\");\n\nvar myAvatar = jasmineReact.renderComponent(<Avatar />);\nmyAvatar.getWidth();\n\nexpect(jasmineReact.classPrototype(Avatar).getWidth).toHaveBeenCalled();\n\n// NOTE: your jasmine-fu will want todo this, but you can't:\n// expect(myAvatar.getWidth).toHaveBeenCalled(); <-- DON'T DO THIS\n```\n\n## jasmineReact.createStubComponent\n\n`jasmineReact.createStubComponent(namespace, className)`\n\nReact components are intended to be composable (using one component inside a render function of another component). While this is great for code reuse, it makes isolating one component for a unit test slightly more difficult.\n\n  *Aside: Why do I want to isolate the component I'm testing from its subcomponents? In a unit test, when you test one component you do want to have to test the behavior of a subcomponent, because that would turn into an integration test.*\n\nWhat you want todo is replace any subcomponent's real definition with a \"test double\". By default this stub component has only the miniumum behavior to be a valid React component: a render function which returns a dom node.\n\nIf you want to add behavior to this stubComponent, so it confirms to the interface of the real component class, use the `jasmineReact.addMethodToClass` function.\n\nLet's say you have an avatar class named `ProfilePic` which is defined on the global namespace, `window`.\nTo replace window.ProfilePic with a stub component (for the life of the jasmine test), you would do:\n\n```js\njasmineReact.createStubComponent(window, \"ProfilePic\");\n```\n\n## jasmineReact.unmountComponent\n\n`jasmineReact.unmountComponent(component);`\n\nThis function makes it easy to unmount a component, given just the component instance.\nUnmounting a component is needed to test `componentWillUnmount` behavior.\n\n```js\nvar myAvatar = jasmineReact.renderComponent(<Avatar />);\njasmineReact.unmountComponent(myAvatar);\n```\n\n## jasmineReact.getDefaultContainer\n\nThe default container for jasmineReact is `document.getElementById(\"jasmine_content\")`.\n\nIf your jasmine test page uses `#spec-dom` as its default dom node, then you'd want to define the following:\n\n```js\njasmineReact.getDefaultContainer = function(){\n  return document.getElementById(\"spec-dom\");\n};\n```\n\n# Installation\n\n```\nnpm install jasmine-react-helpers --save-dev\n```\n\nBower: TODO\n\nScript Tag: TODO\n\n\n# Testing\n\nInstall node, npm, and grunt.\n\nTo run all of the tests (Chrome, Firefox, PhantomJS) with autoWatch:\n\n```bash\ngrunt karma\n```\n\nTo run the tests once with PhantomJS:\n\n```bash\ngrunt karma:unit\n```\n\n# TODO\n\n* Add the following grunt tasks: minification, linting\n* Make the project node compatible (https://blog.codecentric.de/en/2014/02/cross-platform-javascript/)\n* Create a module on npm and bower\n* Add the test suite to Travis CI\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/tommyh/jasmine-react/issues"
  },
  "homepage": "https://github.com/tommyh/jasmine-react",
  "_id": "jasmine-react-helpers@0.2.0",
  "dist": {
    "shasum": "e9f5834b29c280623e71fdbce330588ab4552075"
  },
  "_from": "jasmine-react-helpers@",
  "_resolved": "https://registry.npmjs.org/jasmine-react-helpers/-/jasmine-react-helpers-0.2.0.tgz"
}
