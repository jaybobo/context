{
  "name": "jasmine-react",
  "description": "Jasmine utilities and helpers for testing React components.",
  "version": "1.1.0",
  "homepage": "https://github.com/amireh/jasmine_react",
  "author": {
    "name": "Ahmad Amireh",
    "email": "ahmad@algollabs.com",
    "url": "http://www.algollabs.com"
  },
  "licenses": [],
  "keywords": [],
  "repository": {
    "type": "git",
    "url": "git://github.com/amireh/jasmine_react"
  },
  "bugs": {
    "url": "https://github.com/amireh/jasmine_react/issues"
  },
  "scripts": {
    "default": "grunt",
    "test": "grunt test"
  },
  "devDependencies": {
    "shelljs": "~0.1.2",
    "glob": "x",
    "grunt": "~0.4.0",
    "grunt-contrib-watch": "0.5.x",
    "grunt-contrib-jshint": "~0.6.1",
    "grunt-contrib-connect": "0.3.0",
    "grunt-contrib-jasmine": "~0.6.5",
    "grunt-template-jasmine-requirejs": "git://github.com/amireh/grunt-template-jasmine-requirejs.git#0.2.0",
    "grunt-contrib-requirejs": "x",
    "grunt-string-replace": "0.2.x",
    "grunt-tagrelease": "0.1.x",
    "grunt-bumpup": "0.2.x",
    "grunt-jsduck": "0.1.x"
  },
  "dependencies": {
    "lodash": "1.2.x",
    "jquery": "2.x",
    "react": "0.10.x",
    "rsvp": "3.x",
    "jasmine-rsvp": ">= 1.0.0"
  },
  "readme": "# jasmine_react\n\nTurn a jasmine Suite into one suitable for testing React components.\n\nExample:\n\n```javascript\nvar Checkbox = require('jsx!components/checkbox');\n\ndescribe('Components.Checkbox', function() {\n    this.reactSuite({ type: Checkbox });\n\n    it('should render', function() {\n        expect(subject.isMounted()).toBeTruthy();\n    });\n});\n```\n\n## Features\n\nThe following features will become available to your suite:\n\n### Automatic component (un)mounting\n\nIn your global suite context, \"subject\" will contain a reference to the\n_mounted_ instance of the component you're testing, created and mounted\nduring each test in your suite.\n\n### DOM helpers\n\nAll the DOM helpers detailed below are injected into the global context throughout your tests, so you can conveniently use things like `find()` and `click()`.\n\n> **Note**\n> \n> Most of these helpers operate on nodes *inside* the node of the component \n> being tested, so when you do `find('.foo')` it will look for a child\n> that has the `foo` class only inside the mounted component instance.\n\n\n#### find(selector)\n\nLocate a single element using a jQuery-compatible selector. Returns an `HTMLElement` if found.\n\n```javascript\nit('should show a link', function() {\n  expect(find('a:contains(\"My Link Text\")').length).toBe(1);\n});\n```\n\n#### findAll(selector)\n\nLike `find()` but returns a set of all elements that match the selector.\n\n#### click(selector)\n\nSimulate a mouse-click. If a selector was passed in and it did not yield an element, an error will be thrown.\n\n```javascript\nit('should track clicks', function() {\n  click('button');\n  expect(subject.state.clickCount).toBe(1);\n});\n```\n\n#### check(selector[, isChecked])\n\nToggle the `checked` state of a radio button or a checkbox. You can explicitly set the state by passing `true` or `false` as the second parameter.\n\n```javascript\nit('should track the mute-sound preference', function() {\n    check(':contains(\"Mute Sounds\")', true);\n    expect(subject.state.muteSound).toBe(true);\n});\n```\n\n#### select(selector, value)\n\nChoose an option from a `<select />` dropdown menu. The value parameter should map to the `<option />` element you want to choose.\n\nThere is currently no support for multiple-option dropdowns.\n\n```javascript\nit('should choose my primary currency', function() {\n    select('[name=\"currency\"]', 'JOD');\n    expect(subject.state.currency).toEqual('JOD');\n});\n```\n\n#### fillIn(selector, text)\n\nChange a text-input field's value. This does not simulate typing, the `typeIn` helper does that instead.\n\n```javascript\nit('should track my favorite colour', function() {\n    fillIn('[name=\"colour\"]', 'banana');\n    expect(subject.state.colour).toEqual('banana');\n});\n```\n\n#### typeIn(selector, text[, dontReplace])\n\nSimulate typing into a text field. \n\nTyping in will change the node's `value`, emit the `change` event, along with a `keydown` event for every character in the text.\n\n```javascript\nit('should limit text to 10 chars', function() {\n    typeIn('input', 'hello you should not cut me off really its not nice');\n    expect(subject.state.text).toEqual('hello you');\n});\n```\n\n### Prop helpers\n\n> WARNING!!!\n> \n> This requires jasmine.promiseSuite to be available from\n> [jasmine_rsvp](https://github.com/amireh/jasmine-rsvp).\n\n#### setProps(newProps)\n\nUpdate the component props. Returns an `RSVP.Promise` that fulfills when the component has been re-rendered with the new props.\n\n```javascript\nit('should render the name', function() {\n    expect(find('span.name').innerText).toEqual('');\n\n    setProps({\n        name: 'Ahmad'\n    });\n\n    expect(find('span.name').innerText).toEqual('Ahmad');\n});\n```\n\n#### setState(newState)\n\nSimilar to `#setProps()` but for the component's internal state, which generally you should avoid touching.\n\n### Custom matchers\n\n#### `toExist()`\n\nShortcut for testing that a certain element exists in the DOM.\n\n```javascript\n// Instead of:\nexpect(findAll('.something').length).toEqual(1)\n\n// You can do:\nexpect('.something').toExist();\n```\n\n#### Action testing using `toSendAction(nameOrOptions)`\n\n> WARNING!!!\n> \n> This requires jasmine.promiseSuite to be available from\n> [jasmine_rsvp](https://github.com/amireh/jasmine-rsvp).\n\nThis is very opinionated and most likely won't apply to your code, but it does to mine so it's here. My components are glued to only \"emit\" actions when there's any sort of processing required. This allows me to decouple the UI (components) from actual domain logic handling, and consequently, it makes testing component interaction pretty slick.\n\nTo test if a component is sending actions correctly, a custom matcher\nis exposed to your suite, called `toSendAction()`. The matcher accepts either a string, which would be the event such as `user:signup`, or `account:save`, or a more descriptive object (see below.)\n\nExample:\n\n```javascript\nit(\"should totally remove one's account when clicking the red button\", function() {\n  expect(function() {\n    click('#the_red_button');\n  }).toSendAction('users:unregister');\n});\n```\n\nExample 2: verifying the correct parameters are being sent.\n\nWe can also test the parameters the component is sending. Let's assume we have a `Preferences` component that sends the `updatePreferences` action\nwith the user's chosen preferences.\n\n```jsx\nvar Preferences = React.createClass({\n    render: function() {\n        return (\n            <form>\n                <select ref=\"weekday\">\n                    <option value=\"friday\">Friday</option>\n                    <option value=\"saturday\">Saturday</option>\n                    <option value=\"sunday\">Sunday</option>\n                </select>\n                <button id=\"save\">Save</button>\n            </form>\n        );\n    },\n\n    onClick: function() {\n        this.sendAction('updatePreferences', {\n            weekday: this.refs.weekday.value\n        });\n    }\n});\n```\n\nIf the user chooses Friday to be their starting day of the week, the component should emit the right action with that weekday:\n\n```javascript\nit(\"set the prefered starting weekday\", function() {\n    expect(function() {\n        select('[name=\"weekday\"]', 'Friday');\n        click('#save');\n    }).toSendAction({\n        action: 'updatePreferences',\n        args: {\n            weekday: 'friday'\n        }\n    });\n});\n```\n\n## License\n\nMIT",
  "readmeFilename": "README.md",
  "_id": "jasmine-react@1.1.0",
  "dist": {
    "shasum": "587f84dcb7ab5cf0414e538f850681a28d931b67"
  },
  "_from": "jasmine-react@",
  "_resolved": "https://registry.npmjs.org/jasmine-react/-/jasmine-react-1.1.0.tgz"
}
